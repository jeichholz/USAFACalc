% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/findZeros.R
\name{findZeros}
\alias{findZeros}
\title{findZeros}
\usage{
findZeros(
  expr,
  ...,
  xlim = c(near - within, near + within),
  near = 0,
  within = Inf,
  nearest = 10,
  npts = 1000,
  iterate = 1,
  sortBy = c("byx", "byy", "radial"),
  trySymbolicSingleVar = FALSE,
  forceMultivariableNumeric = FALSE,
  verbose = TRUE,
  roundDigits = 5
)
}
\arguments{
\item{expr}{A formula.  The right side names the variable with respect to which the zeros should be found.
The left side is an expression, e.g. \code{sin(x) ~ x}.
All free variables (all but the variable on the right side) named in the expression must be assigned
a value via \verb{\\ldots}}

\item{...}{Formulas corresponding to additional functions to use in simultaneous zero finding
and/or specific numerical values for the free variables in the expression.}

\item{xlim}{The range of the dependent variable to search for zeros. \code{Inf} is a legitimate value,
but is interpreted in the numerical sense as the non-Inf largest floating point number.  This can also
be specified replacing \code{x} with the name of the variable.  See the examples.}

\item{near}{a value near which zeros are desired}

\item{within}{only look for zeros at least this close to near.  \code{near} and \code{within} provide an
alternative to using \code{xlim} to specify the search space.}

\item{nearest}{the number of nearest zeros to return.  Fewer are returned if fewer are found.}

\item{npts}{How many sub-intervals to divide the \code{xlim} into when looking for candidates for zeros.
The default is usually good enough.
If \code{Inf} is involved, the intervals are logarithmically spaced up to the largest finite floating point number.
There is no guarantee that all the roots will be found.}

\item{iterate}{maximum number of times to iterate the search. Subsequent searches take place with the range
of previously found zeros.  Choosing a large number here is likely to kill performance without
improving results, but a value of 1 (the default) or 2 works well when searching in \code{c(-Inf,Inf)} for
a modest number of zeros near \code{near}.}

\item{sortBy}{specifies how the zeros found will be sorted. Options are 'byx', 'byy', or 'radial'.}

\item{trySymbolicSingleVar}{if TRUE, try using a symbolic solver for solving the single-variable equation rather than skipping right to numeric.}

\item{forceMultivariableNumeric}{if TRUE, skip the symbolic solver for your multivariable system and go right to numeric.}

\item{verbose}{if TRUE, print out information about progress.}

\item{roundDigits}{if x1 and x2 are found numerically, if x1 and x2 round to the same
number at roundDigits place, then treat x1 and x2 as the same root.}
}
\description{
Find a zero of an expression, or system of expressions.

findZeros is a drop-in replacement for mosaic::findZeros.

The goals are as follows:

1) Correctly find roots of all polynomials, even ones that have a repeated root.
2) Return accurate results at all times, that is, if xstar is returned as a root, it should indeed have the property that f(xstar) is near 0.
3) Be able to handle nested functions correctly.  For instance, f(x)=x+1, g(x)=f(x)^2, h(x)=g(x)*f(x)-3.  If we try to find a root of h(x), that should still be treated as a polynomial.
4) Be able to handle functions that are defined as the output of some other, built in, function.  For instance, model=fitModel(...), we should be able to find roots of model.
5) Be able to solve systems of equations, in particular with regard to multivariable optimization and Lagrange multipliers.

The strategy is:
If the expression is single-variable:
1) Treat expr as a polynomial, and use sympy to solve.  If this succeeds, then we are done.
2) If treating as a polynomial fails, then do a traditional multi-start numerical solve.  This is based on a Broyden (Newton-type) method.  Unlike a bracketing method like uniroot,
Newton-type methods can find repeated roots.  The disadvantage is that the make no guarantee about absolutely anything. However, we can state at an absolute ton of points, and it
seems to work reasonably well.
3) If forced to do so, use the general sympy solver before the numerical one.  This has some advantages, for instance it can solve rational functions, etc., exactly.  However,
the general solve command is known to miss some roots and *not* generate an error.  For instance, only two roots are found for sin(x).  Further, it might generate things like asin(2)
as an answer, which is fine as a complex number, but by default R will generate NA when converting this to floating point.  This is not an error, per se, so right now we return
a table full of N/A when trying to solve sin(x)+2=0.
The solver is based on a Broyden method, not a bracketing technique, so it will find repeated roots.

If the expression is multi-variable:
1) Attempt to use a the sympy symbolic solver.  This might miss solutions in some cases. It performs well on multinomial and similar problems
2) If symbolic fails, or if forced to do so, try a numerical solver based on a Broyden method.
}
\examples{
# solve sin(x)=cos(x)
findZeros(sin(x)-cos(x)~x)

}
